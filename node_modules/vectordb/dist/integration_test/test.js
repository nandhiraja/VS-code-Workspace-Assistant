"use strict";
// Copyright 2023 LanceDB Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const mocha_1 = require("mocha");
const chai = require("chai");
const chai_1 = require("chai");
const chaiAsPromised = require("chai-as-promised");
const uuid_1 = require("uuid");
const lancedb = require("../index");
const os_1 = require("os");
const fs = require("fs");
const path = require("path");
chai.use(chaiAsPromised);
(0, mocha_1.describe)('LanceDB AWS Integration test', function () {
    it('s3+ddb schema is processed correctly', async function () {
        this.timeout(15000);
        // WARNING: specifying engine is NOT a publicly supported feature in lancedb yet
        // THE API WILL CHANGE
        const conn = await lancedb.connect('s3://lancedb-integtest?engine=ddb&ddbTableName=lancedb-integtest');
        const data = [{ vector: Array(128).fill(1.0) }];
        const tableName = (0, uuid_1.v4)();
        let table = await conn.createTable(tableName, data, { writeMode: lancedb.WriteMode.Overwrite });
        const futs = [table.add(data), table.add(data), table.add(data), table.add(data), table.add(data)];
        await Promise.allSettled(futs);
        table = await conn.openTable(tableName);
        chai_1.assert.equal(await table.countRows(), 6);
    });
});
(0, mocha_1.describe)('LanceDB Mirrored Store Integration test', function () {
    it('s3://...?mirroredStore=... param is processed correctly', async function () {
        this.timeout(600000);
        const dir = (0, os_1.tmpdir)();
        console.log(dir);
        const conn = await lancedb.connect({ uri: `s3://lancedb-integtest?mirroredStore=${dir}`, storageOptions: { allowHttp: 'true' } });
        const data = Array(200).fill({ vector: Array(128).fill(1.0), id: 0 });
        data.push(...Array(200).fill({ vector: Array(128).fill(1.0), id: 1 }));
        data.push(...Array(200).fill({ vector: Array(128).fill(1.0), id: 2 }));
        data.push(...Array(200).fill({ vector: Array(128).fill(1.0), id: 3 }));
        const tableName = (0, uuid_1.v4)();
        // try create table and check if it's mirrored
        const t = await conn.createTable(tableName, data, { writeMode: lancedb.WriteMode.Overwrite });
        const mirroredPath = path.join(dir, `${tableName}.lance`);
        fs.readdir(mirroredPath, { withFileTypes: true }, (err, files) => {
            if (err != null)
                throw err;
            // there should be three dirs
            chai_1.assert.equal(files.length, 3);
            chai_1.assert.isTrue(files[0].isDirectory());
            chai_1.assert.isTrue(files[1].isDirectory());
            fs.readdir(path.join(mirroredPath, '_transactions'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].name.endsWith('.txn'));
            });
            fs.readdir(path.join(mirroredPath, '_versions'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].name.endsWith('.manifest'));
            });
            fs.readdir(path.join(mirroredPath, 'data'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].name.endsWith('.lance'));
            });
        });
        // try create index and check if it's mirrored
        await t.createIndex({ column: 'vector', type: 'ivf_pq' });
        fs.readdir(mirroredPath, { withFileTypes: true }, (err, files) => {
            if (err != null)
                throw err;
            // there should be four dirs
            chai_1.assert.equal(files.length, 4);
            chai_1.assert.isTrue(files[0].isDirectory());
            chai_1.assert.isTrue(files[1].isDirectory());
            chai_1.assert.isTrue(files[2].isDirectory());
            // Two TXs now
            fs.readdir(path.join(mirroredPath, '_transactions'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 2);
                chai_1.assert.isTrue(files[0].name.endsWith('.txn'));
                chai_1.assert.isTrue(files[1].name.endsWith('.txn'));
            });
            fs.readdir(path.join(mirroredPath, 'data'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].name.endsWith('.lance'));
            });
            fs.readdir(path.join(mirroredPath, '_indices'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].isDirectory());
                fs.readdir(path.join(mirroredPath, '_indices', files[0].name), { withFileTypes: true }, (err, files) => {
                    if (err != null)
                        throw err;
                    chai_1.assert.equal(files.length, 1);
                    chai_1.assert.isTrue(files[0].isFile());
                    chai_1.assert.isTrue(files[0].name.endsWith('.idx'));
                });
            });
        });
        // try delete and check if it's mirrored
        await t.delete('id = 0');
        fs.readdir(mirroredPath, { withFileTypes: true }, (err, files) => {
            if (err != null)
                throw err;
            // there should be five dirs
            chai_1.assert.equal(files.length, 5);
            chai_1.assert.isTrue(files[0].isDirectory());
            chai_1.assert.isTrue(files[1].isDirectory());
            chai_1.assert.isTrue(files[2].isDirectory());
            chai_1.assert.isTrue(files[3].isDirectory());
            chai_1.assert.isTrue(files[4].isDirectory());
            // Three TXs now
            fs.readdir(path.join(mirroredPath, '_transactions'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 3);
                chai_1.assert.isTrue(files[0].name.endsWith('.txn'));
                chai_1.assert.isTrue(files[1].name.endsWith('.txn'));
            });
            fs.readdir(path.join(mirroredPath, 'data'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].name.endsWith('.lance'));
            });
            fs.readdir(path.join(mirroredPath, '_indices'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].isDirectory());
                fs.readdir(path.join(mirroredPath, '_indices', files[0].name), { withFileTypes: true }, (err, files) => {
                    if (err != null)
                        throw err;
                    chai_1.assert.equal(files.length, 1);
                    chai_1.assert.isTrue(files[0].isFile());
                    chai_1.assert.isTrue(files[0].name.endsWith('.idx'));
                });
            });
            fs.readdir(path.join(mirroredPath, '_deletions'), { withFileTypes: true }, (err, files) => {
                if (err != null)
                    throw err;
                chai_1.assert.equal(files.length, 1);
                chai_1.assert.isTrue(files[0].name.endsWith('.arrow'));
            });
        });
    });
});
//# sourceMappingURL=test.js.map